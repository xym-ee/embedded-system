---
sort: 4
---
# 文件系统API

回顾。

器件，物理世界保存 1bit，磁带、磁盘、ssd。

在存储设备的基础上，想用的话，还得努力。IO设备。io设备就是一些寄存器，在寄存器基础上操作系统又做了一些抽象，驱动层，可以读写控制的对象。

对于持久化的存储设备，还有block的操作。

如果操作系统里的应用程序，如果想共享一个设备，

而且程序天生有共享设备的需求，如键盘、屏幕、显卡。

这就有了文件系统的需求。

## 为什么要有文件系统

设备在应用程序之间共享。比如终端。

4个线程或者进程也可以，竞争同一个设备，输出数据到终端。如果使用的是 printf ，那效果符合我们的预期。也即 printf 打印字符串是有原子性的，这是库函数为我们提供的保证(太长了不行)。

如果使用了 putchar 的时候，我们担心的事情就发生了，互相抢设备，出现了乱七八糟的东西。

设备在应用程序上共享是有难度的。

磁盘，block device，让所有的程序共享这个磁盘，有的要 write，有的要 read，该如何使**用好**磁盘呢？

终端作为字符设备，多线程一起 printf 还能接受，最多就是效果差点。但是磁盘，一起 write 是有可能覆盖其他有用的数据的。系统里各种各样的程序要管理各种各样的数据，用户数据、系统数据。

虽然应用程序数据就是字节序列。比如markdown，可以二进制查看，磁盘也是字节序列，可以 `cat vda | head --bytes 512 | xxd` 查看一个磁盘的前 512 bytes，顺便可以看到 55aa 的结尾。

但是**字节序列并不是对磁盘好的抽象**。

那该怎么办呢？

应用程序管理自己的数据，磁盘也是管理的数据，很自然的我们要把磁盘抽象为很多个虚拟磁盘。每个应用程序可以持有很多个虚拟磁盘，有一些是贡献的。

## 文件系统

文件系统：设计目标
- 提供合理的 API 使多个应用程序能共享数据
- 提供一定的隔离，使恶意/出错程序的伤害不能任意扩大


即要做“存储设备 (字节序列) 的虚拟化”
- 磁盘 (I/O 设备) = 一个可以读/写的字节序列
- 虚拟磁盘 (文件) = 一个可以读/写的动态字节序列
命名管理
虚拟磁盘的名称、检索和遍历
数据管理
std::vector<char> (随机读写/resize)

其实也很简单，文件就是一个支持随机读写的字节序列。

文件系统下面是磁盘设备，文件系统里面有好多虚拟磁盘，文件系统最重要的一点是可以根据名字找到合适的文件。操作系统、应用程序都可以用一个合适的方式找到要使用的虚拟磁盘，就是这样。

文件系统就是个应用程序，可以不在操作系统课上讲。

文件系统和其他应用可以做进程间通信实现数据交换。

没有文件系统操作系统啥也干不了，深度绑定，所以还是在操作系统里学。前面学可执行文件，它放在哪里呢？存放在磁盘这个具体介质上，才能加载到内存里。

## 虚拟磁盘：命名管理

文件系统的设计。

如何在这么多文件中找到我们需要的那个。如一个游戏的过场动画，去哪里找。

最简单的实现就是每个文件都有一个独立的名字，key value，这种方式对遍历不太友好。

上百万个文件，如何更快的找呢？分类，比如图书馆。

找书，如果明确的知道这本书的名字，直接去找就好了。但是我们就是随便看看，找一个类型的，那么就去这个分类下的暑假去看就好了。不需要遍历整个图书馆的所有书。

这就是信息的局部性：将虚拟磁盘(文件)组织成层次结构。

目录树，逻辑相关的数据存放在相近的目录

```
.
└── 学习资料
    ├── .学习资料(隐藏)
    ├── 问题求解1
    ├── 问题求解2
    ├── 问题求解3
    ├── 问题求解4
    └── 操作系统
```

总有一个最大的目录。文件系统的根，根节点。
- windows 每个设备(驱动器)是一棵树
  - `C:\` C盘根目录
  - `D:\`
  - u盘分配新的盘符
    - 为什么没有`A:\` `B:\`，挺好玩的事情。AB是软盘驱动器上的软盘。DOS时代的东西。现在软盘没了，但是兼容老设备。很简单粗暴方便，但是也有问题，如果 game.iso 光盘镜像为文件分盘符就费劲，
- unix/linux
  - 只有一个根 `/`
  - 所有的东西都在这里面。
  - 那么U盘插进去怎么来的呢？


这个问题，如果建立起这个目录呢？

windows的每个设备是一个具体的字节序列，设备上的文件是虚拟出来的。

unix允许任意目录“挂载”一个设备代表的目录树。

一个存储设备，字节序列，用目录树里的一个目录来建立关系，这就是挂载。


文件的挂载引入了一个微妙的循环。
- 文件 = 磁盘上的虚拟磁盘
- 挂载文件 = 在虚拟磁盘上虚拟出的虚拟磁盘 🤔

Linux 的处理方式，并不是直接挂载的
- 创建一个 loopback (回环) 设备
  - 设备驱动把 loopback 设备的 read/write 转发到文件的 read/write

shell 里 `lsblk` 可以看到有 loop 设备。

可以用 strace 观察 disk-img.tar.gz 的挂载


查看 linux 所有的系统调用 `man 2 syscalls` 大概几百个，但是很多系统调用有相当丰富的语义，比如 ioctl，挂载的时候用了这个调用。

微软放弃了wsl1.0用api兼容的方式，因为一个ioctl就有千万行代码。要实现这个api，不可能。


windows有一个很直观的文件系统设备，一个驱动器是个文件系统，分类存放，C为系统，D为软件，E为数据。

linux 第一次接触时会很痛苦。每个目录还是缩写，搞不清楚含义。linux 并不是为 0 基础的人设计的，但是在正确的地方有一份好的手册，那么会对这个世界有更多的认识，能做更多的事。

[Filesystem Hierarchy Standard](https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html)


在有文件系统的基础上，就可以去实现各种 api 了。

## 目录api (系统调用)

比如都用过的 mkdir，rmdir(只能删除一个空的目录)，系统调用只提供了最基础的功能。

python 有更好用的api。如果不在意极限的性能的话。

```py
from pathlib import Path

for f in Path('/proc').glob('*/status'):
    print(f.parts[-2], \
        (f.parent / 'cmdline').read_text() or '[kernel]')
```

unix 里还有个有意思的实现。

链接

一个文件出现在不同的地方需要有不同的名字。这个需求是存在的。

如果一个动态库，要在不同地方使用。

shell 里使用 `ln` 命令即可，系统调用为 `link()`

硬链接在文件上才能做，文件系统无法区分谁是先创建的，就和两个指针指向同一个地址一样。因此不能链接目录，也不能跨文件系统。

因此文件系统里还有一种链接为软链接，这是真快捷方式。linux 允许嵌套，但是有跳转上限。

`ln -s` ，系统调用为 `syslink()`

还有个机制是可以链接为环的。这样的话目录就不是一个树了，就是一个目录图。

## 文件api(系统调用)






