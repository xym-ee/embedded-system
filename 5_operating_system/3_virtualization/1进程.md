---
sort: 1
---
# 操作系统上的进程

有关状态机、并发和中断的讨论给我们真正理解操作系统奠定了基础，现在我们正式进入**操作系统和应用程序的 “边界”** 了。让我们把视角回到单线程应用程序，即 “执行计算指令和系统调用指令的状态机”，开始对操作系统和进程的讨论。

这部分的内容
- 线程、进程和操作系统
- UNIX/Linux 进程管理 API

前面讲了很多并发，特别强调了，程序就是状态机。单线程状态机、多线程状态机。

到这里，我们还要用状态机视角来帮助理解操作系统上的进程以及 API。

状态包含：
- 编译出来的汇编指令在代码区，read only，运行时不应该被任何人修改。
- 此外还有数据区，可读可写，这些是共享的。
- 此外还有每个线程自己的状态，如线程栈，自己的线程信息，比如线程名是个指针，指向data中的字符串。
- 寄存器

然后每条指令执行，或者发生中断，都会把状态往前推一步。

上面就是理论。如何把这个理论变成实际的东西呢？前面的上下文切换代码就是。这里有很多的细节。


## 线程、进程和操作系统

线程操作系统的状态机模型，即共享内存+寄存器+线程栈。

进程是什么呢？对于进程的理解参考 minimal.S，这就是进程。

linux 操作系统下的进程模型和线程模型有什么区别呢？区别是每个进程有自己的内存，有自己的堆栈，但是呢，不共享内存。每个进程有自己的独立内存，这就是进程模型。

计算机有个重要机制，虚拟内存，带上了 VR 眼镜，并且是强制的。每个“线程”只能看到自己的内存。

因此理解了线程，再去理解进程是比较容易的。

什么是操作系统呢？操作系统是状态机的管理者。而且操作系统自己本身也是个状态机。

操作系统自己有私有的内存，剩下的内存分配给状态机，初始的时候，操作系统的代码完成了整个操作系统的初始化后，会加载一个进程(初始状态)，只有一个 init 进程被启动，从此以后，操作系统内核就化身为了一个事件驱动的程序、状态机的管理者，仅在中断和系统调用发生时开始执行。我们看到的其他的所有进程，完全是由第一个 init 进程创建出来的。

做了那么多铺垫以后，终于看到了一个事实：所有的进程都和 minimal.S 一样，要么是 syscall 要么是普通指令。

为了从第一个 init 进程创建其他进程，我们需要的系统调用的 api 是状态机的管理。即创建状态机、销毁状态机···

这个 api 随意设计，如
- CreateProcess(exec_file)
- TerminateProcess()

windows就是这么设计的。


## 复制状态机：fork()

一个容易想到的创建新进程的方法，比如 `create("/bin/init")` ，但是 unix 里实现了一个比较有趣的系统调用。

### 创建新状态机

unix 设计了很有意思的机制，不像 CreateProcess 一样直接给个新状态机给初始状态。

unix 创建新状态机的系统调用 `fork()`，做一份当前状态机的完成复制。

fork 含义是叉子，一个执行流，经过 fork 就分叉了。C 程序 = 状态机，fork做的事情就是把状态机完整的复制一份。就这样。

完全一样指的是，寄存器完全一样，内存的每个字节都完全一样，除了 fork 的返回值了新的 PID。每个进程有个编号。初此之外，两个进程完全没有区别。

到这里操作系统的执行模型就变了，变成一个并发程序。和多线程一样，这里操作系统想执行一步的话，可以选择不同的进程来执行。

操作系统就是一个状态机的管理者。虚拟化就是操作系统里可以管理好多个状态机，每次操作系统可以选一个进程执行。

操作系统里容纳了很多个状态机，但是每次只选一个执行，这就是操作系统的功能。

就这样。

当然还需要花点时间来理解。

先看一个有趣的例子：

Fork Bomb 无限制的创建状态机。

```bash
:(){:|:&};:   # 刚才的一行版本
```
```bash
:() {         # 格式化一下
  : | : &
}; :
```
```bash
fork() {      # bash: 允许冒号作为标识符……
  fork | fork &
}; fork
```

bash 可以把 `:` 用作函数名。递归创建新进程。

因为状态机是复制的，所以总是能找到“父子关系”，这就是进程树 `pstree`，**fork 是 unix 里创建进程的唯一方法。**

为什么这么设计呢？

这样设计可以共享父子进程的状态，可以配合实现一些工作。比如父进程预处理，fork 10 个子进程做并行计算。这里只是简单讲讲，后面会更具体的

一些面试题 or 习题

### 理解 fork：习题1

```c
#include <unistd.h>
#include <stdio.h>

pid_t x = fork();
pid_t y = fork();
printf("%d %d\n", x, y);
```
这段代码总共创建了多少个进程？

理解完整复制当前状态的含义。

这段程序的输出值，这就带来了并发。


### 理解 fork：习题2

这个程序的输出结果

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
  for (int i = 0; i < 2; i++) {
    fork();
    printf("Hello\n");
  }
}
```

每次 fork 完会打印一个 hello，浅看一下，应该会有 6 个。直接编译执行后确实也是。

但是，如果 `./a.out | wc --lines` 话，结果是 8。当然可以认为有空白字符，但是管道到 vim 里发现真的有8行 hello。还可以 `./a.out | cat` 发现真的有 8 个。

机器永远是对的。除了问题，肯定是对机器不够了解。

很有意思，出现 bug 可能是哪个环节呢？如何调试呢？看看指令序列发生了什么，对比 system call trace。

通过strace查看 write 的系统调用，发现次数不一样。(调试的方法)

如何我们对 fork 的理解是正确的，那么一定就有我们未完全掌握的东西：程序会根据输出到终端还是管道做出不同的行为。立即输出还是输出到缓冲区稍后输出。没有立即输出的内容也被复制了一份，这符合我们对 fork 的理解。

基于状态机模型，我们对 printf 隐含了一些假设：当一个进程执行到printf，立马打印一个出来。但是这个函数的行为并不是这样的。

题外话：更深入的理解标准库的缓冲区，看这些例子：

```c
#include <stdio.h>

int main()
{
  printf("hello");
  int *p = NULL;
  *p = 1;
}
```

printf 后执行一个非法操作，程序会崩，但是 hello 也没了。

```c
#include <stdio.h>

int main()
{
  printf("hello\n");
  int *p = NULL;
  *p = 1;
}
```
但是，多了 `\n` ，居然又出来了。 

如果把这个程序的标准输出管道给另一个程序，会发现又没了。

fork 是无情的复制机器，会把所有的东西都拷贝一遍，包括内部的库函数，以及状态。如果需要正确的打印出来，需要一个 `fflush(stdout);` ，它会执行一个系统调用，真正的把字符输出到文件里。当然库函数为了更快，执行系统调用需要时间，他会把字符留在缓冲区里，根据输出对象的不同，有不同的缓冲区。如果输出在终端，那么就是个 line buffer，如果是管道或文件，就是 full buffer。

line buffer 的含义是看到 `\n` 就把缓冲区都写出来。full buffer 会攒够 4096 Byte(页面) 一起丢给操作系统输出出去，除非显示调用`fflush();`

因此，前面的例子就是把没输出的缓冲区也复制了，攒到一起一并输出。

### 习题3*

多线程程序的某个线程执行 fork 会发生什么？

创造 fork 的人并没有考虑线程。这是个好玩的问题。unix 的设计者在实现 fork 的时候没考虑这个问题，以至于后来 posix 引入线程后在 fork 和线程的交互还要打上一些补丁。无论怎么设计都有一些小麻烦，后面说。

我们可能作出以下设计：
- 仅有执行 fork 的线程被复制，其他线程 “卡死”
- 仅有执行 fork 的线程被复制，其他线程退出
- 所有的线程都被复制并继续执行
  - 这三种设计分别会带来什么问题

如果不仅仅想创建init 的副本。还想创建别的程序呢？除了 fork 还应该有个系统调用实现这个功能。


## execve()

fork 完全一样的复制了一个状态机，为了得到我们看到的花哨的，多彩的操作系统。还需要一个系统调用，重置初始状态的调用。

重置状态机的时候，可以给其传参数。系统调用声明：

```c
int execve(const char *filename,
           char * const argv[], char * const envp[]);
```

执行名为 filename 的程序，后面两个刚好对应了 main() 的参数！`argv` 就是 `main` 的参数，`envp` 为环境。所有的资源还在，进程号不变，但是状态都被重置了。

整个计算机系统如何建立联系的呢？

操作系统里面有很多对象是可执行文件，如 `a.out`，a.out 在接收到参数后做参数指定的事情，如 `ls -l`，`ssh xxx`，execve 的行为是把一个 ELF 文件搬到内存里，把状态机重置成 ELF 描述的初始状态。每个可执行文件就描述一个状态机。execve就是重置状态机并且给 C 语言的 main 传递两个参数。

设计的干净又简单。

**execve 是唯一的能够执行程序的系统调用。**

所有的进程的 `strace` 的第一个系统调用都是 `execve`

举个例子

```c
#include <unistd.h>
#include <stdio.h>

int main() {
  char * const argv[] = {
    "/bin/bash", "-c", "env", NULL,
  };
  char * const envp[] = {
    "HELLO=WORLD", NULL,
  };
  execve(argv[0], argv, envp);
  printf("Hello, World!\n");
}
```

这个程序执行 `/bin/bash` ，`-c` 代表执行，env 打印出当前的环境变量，以 NULL 结尾，手册规定的。

当前 sh 的环境变量 `bash -c env`，运行上面的程序，如果成功执行，会看到状态机被重置为 `/bin/bash` 这个程序，并给后面的参数。而且环境变量被改掉了。重要的是，printf没有被执行(理解重置的含义，所有的状态都没有了)。

关于环境变量的讨论

```c
int main (int argc, char* argv[], char* envp[]);
```

完整的main函数，参数个数(count)，参数向量(vector)，环境变量。

什么是环境变量呢？操作系统在运行时，有进程的父子关系，比如说有很多的 shell，如远程的，本地的，在桌面 shell 里执行 `gedit aaa.c` ，这个图形界面程序为何能在当前屏幕画出东西？如果有两个屏幕，应该显示在那个屏幕呢？如果远程 ssh 到服务器上，然后 gedit.c 会在自己的电脑上弹出窗口，shell 执行在服务器上。这也是很有意思的事情。

每个运行的程序，除了命令行参数意外，还给了一个环境。当前程序运行的环境，用 `env` 可以查看环境变量。这个参数也是由 execve 这个系统调用传进去的，作为第 3 个参数。

execv 系列函数里，会继承父进程的环境变量。export 可以告诉 shell 在创建子进程时设置环境变量，然后启动子进程，把环境就带给子进程了。

一个好玩的东西，bash，有个环境变量 PS1，shell 的提示符。如果 `export PS1=':'` ，提示符就会变。可以换成任何值。在继续启动子进程也是这个提示符。


还有个好玩的。PATH 这个环境变量。

前面有 gcc 的 strace 结果。我们知道 execve pathname 必须是个文件，如果要执行 as，会拼接所有的 PATH，直到成功
```
[pid 28369] execve("/usr/local/sbin/as", ["as", "--64", ...
[pid 28369] execve("/usr/local/bin/as", ["as", "--64", ...
[pid 28369] execve("/usr/sbin/as", ["as", "--64", ...
[pid 28369] execve("/usr/bin/as", ["as", "--64", ...
```

一路往下找，直到成功找到。这个搜索顺序是 PATH 里指定的顺序。

我们可以 hack 这个行为。`PATH="" /usr/bin/gcc a.c` 这就会报错。即用我们指定的空路径，我们用绝对路径制定了 gcc，但是后面找不到其它可执行文件了。

到这里，就真的创建了整个计算机系统里所有的东西了。

## _exit()

现在，还缺一些东西。程序被创建出来了，还需要被销毁。应该还要有一个系统调用，执行这个系统调用的状态机从操作系统里消失。

```c
void _exit(int status);
```

至于为什么是 _exit 而不是 exit，因为 exit 是 C 标准库的函数。

- 销毁当前状态机，并允许有一个返回值
- 子进程终止会通知父进程 (后续课程解释)

问题又来了：多线程程序，删除所有线程，还是删除一个线程？

这就有许多种情况了。

- `exit(0);` libc的函数，c 库函数，平缓的结束
- `_exit(0);` 绝对粗暴的推出，直接抹掉状态机

## 总结

这部分的内容

- 操作系统如何管理程序 (进程)？
  - fork, execve, exit: 状态机的复制、重置、销毁
  - 理论上就可以实现 “各种功能” 了！

所有的这些，**状态机管理**。


---




